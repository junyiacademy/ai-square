name: Cleanup Cloud Resources

on:
  schedule:
    # Run every Sunday at 2:00 AM UTC (10:00 AM Taiwan time)
    - cron: '0 2 * * 0'
  workflow_dispatch:  # Allow manual trigger

env:
  PROJECT_ID: ai-square-463013
  REGION: asia-east1

jobs:
  cleanup-cloud-resources:
    name: Clean up GCR images and Cloud Run revisions
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Set up Cloud SDK project
        run: |
          gcloud config set project ${{ env.PROJECT_ID }}
          echo "‚úÖ Project configured: ${{ env.PROJECT_ID }}"

      - name: Clean up Cloud Run revisions
        run: |
          echo "üßπ Starting Cloud Run revisions cleanup..."
          echo "================================================"

          # Global counters for tracking
          GLOBAL_DELETED_COUNT=0
          GLOBAL_FAILED_COUNT=0

          # Function to clean up revisions for a service
          cleanup_service_revisions() {
            local SERVICE=$1
            local KEEP_COUNT=${2:-3}  # Keep latest 3 revisions by default
            local DELETED_COUNT=0
            local FAILED_COUNT=0

            echo ""
            echo "üì¶ Cleaning service: $SERVICE"
            echo "   Keeping latest $KEEP_COUNT revisions"

            # Get all revision names sorted by creation time (newest first)
            # Remove error suppression to see actual issues
            REVISIONS=$(gcloud run revisions list \
              --service=${SERVICE} \
              --region=${{ env.REGION }} \
              --sort-by="~metadata.creationTimestamp" \
              --format="value(metadata.name)" 2>&1)

            # Check for errors
            if echo "$REVISIONS" | grep -q "ERROR"; then
              echo "   ‚ö†Ô∏è Service not found or error listing revisions"
              echo "   Error: $REVISIONS"
              return
            fi

            if [ -z "$REVISIONS" ]; then
              echo "   ‚ö†Ô∏è No revisions found"
              return
            fi

            # Count total revisions
            TOTAL=$(echo "$REVISIONS" | wc -l)

            if [ $TOTAL -gt $KEEP_COUNT ]; then
              echo "   üìä Found $TOTAL revisions"

              # Get revisions to delete (skip the first KEEP_COUNT)
              TO_DELETE=$(echo "$REVISIONS" | tail -n +$((KEEP_COUNT + 1)))
              TO_DELETE_COUNT=$(echo "$TO_DELETE" | wc -l)
              echo "   üéØ Will attempt to delete $TO_DELETE_COUNT revisions"

              # Process each revision
              while IFS= read -r REVISION; do
                if [ -n "$REVISION" ]; then
                  echo "   üóëÔ∏è Deleting: $REVISION"

                  # Try to delete, capture output
                  DELETE_OUTPUT=$(gcloud run revisions delete $REVISION \
                    --region=${{ env.REGION }} \
                    --quiet 2>&1)

                  if [ $? -eq 0 ]; then
                    DELETED_COUNT=$((DELETED_COUNT + 1))
                    echo "      ‚úÖ Successfully deleted"
                  else
                    FAILED_COUNT=$((FAILED_COUNT + 1))
                    echo "      ‚ùå Failed to delete"
                    echo "      Error: ${DELETE_OUTPUT}"
                  fi
                fi
              done <<< "$TO_DELETE"

              # Update global counters
              GLOBAL_DELETED_COUNT=$((GLOBAL_DELETED_COUNT + DELETED_COUNT))
              GLOBAL_FAILED_COUNT=$((GLOBAL_FAILED_COUNT + FAILED_COUNT))

              echo "   üìä Service cleanup results:"
              echo "      ‚úÖ Deleted: $DELETED_COUNT"
              echo "      ‚ùå Failed: $FAILED_COUNT"
              echo "      üìÅ Remaining: $KEEP_COUNT"
            else
              echo "   ‚úÖ Only $TOTAL revisions exist, no cleanup needed"
            fi
          }

          # Clean up staging service (development phase - minimal retention)
          cleanup_service_revisions "ai-square-staging" 1

          # Clean up production service (keep 2 for rollback)
          cleanup_service_revisions "ai-square-production" 2

          echo ""
          echo "================================================"
          echo "üìä Cloud Run Cleanup Summary:"
          echo "   ‚úÖ Total deleted: $GLOBAL_DELETED_COUNT revisions"
          echo "   ‚ùå Total failed: $GLOBAL_FAILED_COUNT revisions"
          echo "================================================"

      - name: Clean up GCR images
        run: |
          set +e  # Don't exit on error
          echo ""
          echo "üßπ Starting GCR images cleanup..."
          echo "================================================"

          # Global counters for tracking
          GLOBAL_IMAGE_DELETED=0
          GLOBAL_IMAGE_FAILED=0
          GLOBAL_IMAGE_SKIPPED=0

          # First, get images currently in use by Cloud Run
          echo "üîç Checking images currently in use by Cloud Run..."
          IMAGES_IN_USE=""
          for SERVICE in "ai-square-staging" "ai-square-production"; do
            # Get all revisions for this service
            REVISIONS=$(gcloud run revisions list \
              --service=$SERVICE \
              --region=${{ env.REGION }} \
              --format="value(spec.containers[0].image)" 2>/dev/null)

            if [ -n "$REVISIONS" ]; then
              IMAGES_IN_USE="$IMAGES_IN_USE"$'\n'"$REVISIONS"
            fi
          done

          # Extract unique digests from images in use (normalize to sha256: format)
          PROTECTED_DIGESTS=$(echo "$IMAGES_IN_USE" | grep -oE '@sha256:[a-f0-9]{64}' | sed 's/@//' | sort -u)
          PROTECTED_COUNT=$(echo "$PROTECTED_DIGESTS" | wc -l)
          echo "   üìå Found $PROTECTED_COUNT unique images in use"
          
          # Debug: show protected digests
          if [ -n "$PROTECTED_DIGESTS" ]; then
            echo "   üîí Protected digests:"
            echo "$PROTECTED_DIGESTS" | sed 's/^/      /'
          else
            echo "   ‚ö†Ô∏è No protected digests found - will only keep latest $KEEP_COUNT by age"
          fi

          # Function to clean up container images
          cleanup_repository() {
            local REPO=$1
            local KEEP_COUNT=${2:-5}  # Keep latest 5 images by default
            local DELETED_COUNT=0
            local FAILED_COUNT=0
            local SKIPPED_COUNT=0

            echo ""
            echo "üì¶ Cleaning repository: ${REPO##*/}"
            echo "   Keeping latest $KEEP_COUNT images"

            # Check if repository exists
            REPO_CHECK=$(gcloud container images list --repository="$REPO" 2>&1)
            if [ $? -ne 0 ]; then
              echo "   ‚ö†Ô∏è Repository not found or error: $REPO"
              echo "   Error: $REPO_CHECK"
              return
            fi

            # Get all images sorted by timestamp (newest first) - get full sha256 digests via JSON
            RAW_IMAGES=$(gcloud container images list-tags "$REPO" \
              --format="json" \
              --sort-by="~timestamp" 2>&1)
            
            # Extract just the digests (with sha256: prefix)
            IMAGES=$(echo "$RAW_IMAGES" | jq -r '.[].digest' 2>/dev/null || echo "")
            
            # Get total count
            TOTAL_IMAGES=$(echo "$IMAGES" | grep -c '^sha256:' || echo "0")

            echo "   üìä Total images in repository: $TOTAL_IMAGES"

            # Check for errors
            if echo "$IMAGES" | grep -q "ERROR"; then
              echo "   ‚ùå Error listing images: $IMAGES"
              return
            fi

            # Filter out empty lines and get images to delete (skip the first KEEP_COUNT)
            ALL_IMAGES=$(echo "$IMAGES" | grep -v '^$')
            TO_DELETE=$(echo "$ALL_IMAGES" | tail -n +$((KEEP_COUNT + 1)))

            if [ -n "$TO_DELETE" ]; then
              IMAGE_COUNT=$(echo "$TO_DELETE" | wc -l)
              echo "   üéØ Will attempt to process $IMAGE_COUNT old images"

              # Process each image
              while IFS= read -r DIGEST; do
                if [ -n "$DIGEST" ]; then
                  # Check if this digest is in use (only if we have protected digests)
                  if [ -n "$PROTECTED_DIGESTS" ] && echo "$PROTECTED_DIGESTS" | grep -q "$DIGEST"; then
                    SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
                    echo "   ‚è≠Ô∏è Skipping ${DIGEST:0:19}... (in use by Cloud Run)"
                    continue
                  fi

                  echo "   üóëÔ∏è Deleting: ${DIGEST:0:19}..."

                  # Try to delete with better error handling
                  DELETE_OUTPUT=$(gcloud container images delete "$REPO@$DIGEST" \
                    --quiet --force-delete-tags 2>&1)

                  if [ $? -eq 0 ]; then
                    DELETED_COUNT=$((DELETED_COUNT + 1))
                    echo "      ‚úÖ Successfully deleted"
                  else
                    FAILED_COUNT=$((FAILED_COUNT + 1))
                    echo "      ‚ùå Failed to delete"
                    # Check for common error patterns with better diagnostics
                    if echo "$DELETE_OUTPUT" | grep -q "referenced by"; then
                      echo "      ‚ö†Ô∏è Image is referenced by parent images (cannot delete)"
                    elif echo "$DELETE_OUTPUT" | grep -q "in use by"; then
                      echo "      ‚ö†Ô∏è Image is in use (protected)"
                    elif echo "$DELETE_OUTPUT" | grep -q "V2DiagnosticException"; then
                      echo "      ‚ö†Ô∏è Registry error (possibly phantom image)"
                    elif echo "$DELETE_OUTPUT" | grep -q "404"; then
                      echo "      ‚ö†Ô∏è Image not found (already deleted?)"
                    elif echo "$DELETE_OUTPUT" | grep -q "Invalid value"; then
                      echo "      ‚ö†Ô∏è Invalid digest format: $DIGEST"
                    else
                      echo "      ‚ö†Ô∏è Error: ${DELETE_OUTPUT:0:150}..."
                    fi
                  fi
                fi
              done <<< "$TO_DELETE"

              # Update global counters
              GLOBAL_IMAGE_DELETED=$((GLOBAL_IMAGE_DELETED + DELETED_COUNT))
              GLOBAL_IMAGE_FAILED=$((GLOBAL_IMAGE_FAILED + FAILED_COUNT))
              GLOBAL_IMAGE_SKIPPED=$((GLOBAL_IMAGE_SKIPPED + SKIPPED_COUNT))

              echo "   üìä Repository cleanup results:"
              echo "      ‚úÖ Deleted: $DELETED_COUNT"
              echo "      ‚è≠Ô∏è Skipped: $SKIPPED_COUNT (in use)"
              echo "      ‚ùå Failed: $FAILED_COUNT"
              echo "      üìÅ Kept: $KEEP_COUNT (latest)"
              echo "      üì¶ Total remaining: $((KEEP_COUNT + SKIPPED_COUNT + FAILED_COUNT))"
            else
              echo "   ‚úÖ Only $TOTAL_IMAGES images exist, no cleanup needed"
            fi
          }

          # Clean up staging images (development phase - minimal retention)
          cleanup_repository "gcr.io/${{ env.PROJECT_ID }}/ai-square-staging" 2

          # Clean up production images (keep 3 for safety)
          cleanup_repository "gcr.io/${{ env.PROJECT_ID }}/ai-square-production" 3

          echo ""
          echo "================================================"
          echo "üìä GCR Cleanup Summary:"
          echo "   ‚úÖ Total deleted: $GLOBAL_IMAGE_DELETED images"
          echo "   ‚è≠Ô∏è Total skipped: $GLOBAL_IMAGE_SKIPPED images (in use by Cloud Run)"
          echo "   ‚ùå Total failed: $GLOBAL_IMAGE_FAILED images"
          echo "================================================"

      - name: Generate cleanup report
        if: always()
        run: |
          echo ""
          echo "üìã Final Cleanup Verification Report"
          echo "================================================"
          echo "üïê Execution time: $(date +'%Y-%m-%d %H:%M:%S UTC')"
          echo "üì¶ Project: ${{ env.PROJECT_ID }}"
          echo "üåç Region: ${{ env.REGION }}"
          echo ""

          # Verification: Show actual current resource usage
          echo "üîç VERIFICATION - Current Resource Status:"
          echo "----------------------------"

          # Count Cloud Run services and revisions
          echo ""
          echo "üèéÔ∏è Cloud Run Status:"
          echo "------------------"

          # List services with revision count
          for SERVICE in "ai-square-staging" "ai-square-production"; do
            REVISION_COUNT=$(gcloud run revisions list \
              --service=$SERVICE \
              --region=${{ env.REGION }} \
              --format="value(metadata.name)" 2>/dev/null | wc -l)

            if [ $REVISION_COUNT -gt 0 ]; then
              echo "  $SERVICE: $REVISION_COUNT revision(s)"

              # Show revision details
              echo "    Latest revisions:"
              gcloud run revisions list \
                --service=$SERVICE \
                --region=${{ env.REGION }} \
                --limit=3 \
                --format="table(metadata.name:label='REVISION',metadata.creationTimestamp:label='CREATED')" 2>/dev/null | \
                sed 's/^/      /'
            else
              echo "  $SERVICE: Service not found or no revisions"
            fi
          done

          echo ""
          echo "üñºÔ∏è GCR Image Status:"
          echo "------------------"

          # Verify actual image counts
          for REPO in "ai-square-staging" "ai-square-production"; do
            IMAGE_COUNT=$(gcloud container images list-tags "gcr.io/${{ env.PROJECT_ID }}/$REPO" \
              --format="value(digest)" 2>/dev/null | wc -l)

            if [ $IMAGE_COUNT -gt 0 ]; then
              echo "  $REPO: $IMAGE_COUNT image(s) remaining"

              # Show latest images
              echo "    Latest images:"
              gcloud container images list-tags "gcr.io/${{ env.PROJECT_ID }}/$REPO" \
                --limit=3 \
                --sort-by="~timestamp" \
                --format="table(timestamp.date('%Y-%m-%d %H:%M'):label='CREATED',digest.slice(7:19):label='DIGEST')" 2>/dev/null | \
                sed 's/^/      /'
            else
              echo "  $REPO: No images found"
            fi
          done

          echo ""
          echo "üéØ Cleanup Effectiveness Check:"
          echo "--------------------------------"

          # Check if cleanup met targets
          STAGING_IMAGES=$(gcloud container images list-tags "gcr.io/${{ env.PROJECT_ID }}/ai-square-staging" \
            --format="value(digest)" 2>/dev/null | wc -l)
          PROD_IMAGES=$(gcloud container images list-tags "gcr.io/${{ env.PROJECT_ID }}/ai-square-production" \
            --format="value(digest)" 2>/dev/null | wc -l)

          CLEANUP_SUCCESS=true

          if [ $STAGING_IMAGES -le 2 ]; then
            echo "  ‚úÖ Staging images: $STAGING_IMAGES (target: ‚â§2)"
          else
            echo "  ‚ö†Ô∏è Staging images: $STAGING_IMAGES (target: ‚â§2) - NEEDS ATTENTION"
            CLEANUP_SUCCESS=false
          fi

          if [ $PROD_IMAGES -le 3 ]; then
            echo "  ‚úÖ Production images: $PROD_IMAGES (target: ‚â§3)"
          else
            echo "  ‚ö†Ô∏è Production images: $PROD_IMAGES (target: ‚â§3) - NEEDS ATTENTION"
            CLEANUP_SUCCESS=false
          fi

          echo ""
          if [ "$CLEANUP_SUCCESS" = true ]; then
            echo "üéÜ Cleanup workflow completed successfully!"
            echo "All targets met. Resources are within expected limits."
          else
            echo "‚ö†Ô∏è Cleanup workflow completed with warnings!"
            echo "Some resources exceed target limits. Manual intervention may be required."
          fi

      - name: Send Slack notification (if configured)
        if: always() && env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          # Only send notification if webhook is configured
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            REVISION_COUNT=$(gcloud run revisions list --region=${{ env.REGION }} --format="value(metadata.name)" 2>/dev/null | wc -l)

            curl -X POST $SLACK_WEBHOOK_URL \
              -H 'Content-Type: application/json' \
              -d "{
                \"text\": \"üßπ Cloud Resources Cleanup Complete\",
                \"blocks\": [
                  {
                    \"type\": \"header\",
                    \"text\": {
                      \"type\": \"plain_text\",
                      \"text\": \"üßπ AI Square Cloud Resources Cleanup\"
                    }
                  },
                  {
                    \"type\": \"section\",
                    \"text\": {
                      \"type\": \"mrkdwn\",
                      \"text\": \"*Status:* ‚úÖ Completed\\n*Time:* $(date +'%Y-%m-%d %H:%M UTC')\\n*Active Revisions:* $REVISION_COUNT\"
                    }
                  }
                ]
              }"
          fi
