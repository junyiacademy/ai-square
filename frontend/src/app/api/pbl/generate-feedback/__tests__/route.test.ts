/**
 * PBL Generate Feedback Route Tests
 * 提升覆蓋率從 0% 到 80%+
 * 
 * This API handles AI-powered feedback generation for PBL programs with:
 * - Multi-language support
 * - Feedback caching and versioning
 * - Complex evaluation data processing
 * - AI integration with schema validation
 */

import { NextRequest } from 'next/server';
import { POST } from '../route';
import { getServerSession } from '@/lib/auth/session';
import { VertexAI } from '@google-cloud/vertexai';
import type { IScenario, IProgram, ITask, IEvaluation } from '@/types/unified-learning';
import { mockConsoleError, mockConsoleLog } from '@/test-utils/helpers/console';

// Mock dependencies
jest.mock('@/lib/auth/session');
jest.mock('@/lib/utils/language', () => ({
  ...jest.requireActual('@/lib/utils/language'),
  getLanguageFromHeader: jest.fn(() => 'en')
}));

// Mock Vertex AI with factory function to avoid hoisting issues
jest.mock('@google-cloud/vertexai', () => {
  const mockGenerateContent = jest.fn();
  return {
    VertexAI: jest.fn().mockImplementation(() => ({
      getGenerativeModel: jest.fn().mockReturnValue({
        generateContent: mockGenerateContent
      })
    })),
    SchemaType: {
      OBJECT: 'object',
      STRING: 'string',
      ARRAY: 'array'
    },
    // Export the mock for test access
    __mockGenerateContent: mockGenerateContent
  };
});

// Mock console methods
const mockError = mockConsoleError();
const mockLog = mockConsoleLog();

// Mock repositories
const mockProgramRepo = {
  findById: jest.fn(),
  update: jest.fn()
};
const mockEvalRepo = {
  findById: jest.fn(),
  update: jest.fn()
};
const mockTaskRepo = {
  findById: jest.fn(),
  findByProgram: jest.fn()
};
const mockUserRepo = {
  findByEmail: jest.fn()
};
const mockScenarioRepo = {
  findById: jest.fn()
};

// Mock the repository factory module
jest.mock('@/lib/repositories/base/repository-factory', () => ({
  repositoryFactory: {
    getProgramRepository: () => mockProgramRepo,
    getEvaluationRepository: () => mockEvalRepo,
    getTaskRepository: () => mockTaskRepo,
    getUserRepository: () => mockUserRepo,
    getScenarioRepository: () => mockScenarioRepo
  }
}));

describe('POST /api/pbl/generate-feedback', () => {
  // Mock data
  const mockUser = {
    id: 'user-123',
    email: 'test@example.com',
    profile: {},
    preferences: {},
    createdAt: '2024-01-01T00:00:00Z',
    updatedAt: '2024-01-01T00:00:00Z'
  };

  const mockProgram: IProgram = {
    id: 'program-123',
    scenarioId: 'scenario-123',
    userId: 'user-123',
    mode: 'pbl',
    status: 'completed',
    currentTaskIndex: 2,
    completedTaskCount: 3,
    totalTaskCount: 3,
    totalScore: 85,
    domainScores: {},
    xpEarned: 100,
    badgesEarned: [],
    timeSpentSeconds: 1800,
    lastActivityAt: '2024-01-01T00:00:00Z',
    pblData: {},
    discoveryData: {},
    assessmentData: {},
    createdAt: '2024-01-01T00:00:00Z',
    updatedAt: '2024-01-01T00:00:00Z',
    metadata: {
      evaluationId: 'eval-123'
    }
  };

  const mockEvaluation: IEvaluation = {
    id: 'eval-123',
    taskId: 'program-123',
    userId: 'user-123',
    mode: 'pbl',
    evaluationType: 'summative',
    score: 85,
    feedbackText: 'Good performance overall',
    maxScore: 100,
    domainScores: {},
    feedbackData: {},
    aiProvider: 'vertex-ai',
    aiModel: 'gemini-2.5-flash',
    aiAnalysis: {},
    timeTakenSeconds: 1800,
    pblData: {},
    discoveryData: {},
    assessmentData: {},
    createdAt: '2024-01-01T00:00:00Z',
    metadata: {
      evaluatedTasks: 3,
      totalTasks: 3,
      totalTimeSeconds: 1800,
      domainScores: {
        'Creating with AI': 80,
        'Engaging with AI': 90,
        'Managing AI': 85
      },
      lastSyncedAt: '2024-01-01T00:00:00Z'
    }
  };

  const mockScenario: IScenario = {
    id: 'scenario-123',
    mode: 'pbl',
    status: 'active',
    version: '1.0',
    sourceType: 'yaml',
    sourceMetadata: {},
    title: { en: 'AI Literacy Scenario', zh: 'AI 素養情境' },
    description: { en: 'Learn AI literacy', zh: '學習 AI 素養' },
    objectives: ['Learn AI basics', 'Practice AI interaction'],
    difficulty: 'beginner',
    estimatedMinutes: 45,
    prerequisites: [],
    taskTemplates: [],
    taskCount: 3,
    xpRewards: {},
    unlockRequirements: {},
    pblData: {},
    discoveryData: {},
    assessmentData: {},
    aiModules: {},
    resources: [],
    createdAt: '2024-01-01T00:00:00Z',
    updatedAt: '2024-01-01T00:00:00Z',
    metadata: {
      learningObjectives: ['Understand AI capabilities', 'Practice ethical AI use']
    }
  };

  const mockTasks: ITask[] = [
    {
      id: 'task-1',
      programId: 'program-123',
      mode: 'pbl',
      taskIndex: 0,
      scenarioTaskIndex: 0,
      type: 'question',
      status: 'completed',
      title: { en: 'Task 1' },
      description: { en: 'First task' },
      content: { instructions: ['Do this'] },
      interactions: [],
      interactionCount: 0,
      userResponse: {},
      score: 80,
      maxScore: 100,
      allowedAttempts: 3,
      attemptCount: 1,
      timeSpentSeconds: 600,
      aiConfig: {},
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-01T00:00:00Z',
      pblData: {},
      discoveryData: {},
      assessmentData: {},
      metadata: {
        evaluationId: 'task-eval-1'
      }
    },
    {
      id: 'task-2',
      programId: 'program-123',
      mode: 'pbl',
      taskIndex: 1,
      scenarioTaskIndex: 1,
      type: 'chat',
      status: 'completed',
      title: { en: 'Task 2' },
      description: { en: 'Second task' },
      content: { instructions: ['Do that'] },
      interactions: [],
      interactionCount: 0,
      userResponse: {},
      score: 90,
      maxScore: 100,
      allowedAttempts: 3,
      attemptCount: 1,
      timeSpentSeconds: 600,
      aiConfig: {},
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-01T00:00:00Z',
      pblData: {},
      discoveryData: {},
      assessmentData: {},
      metadata: {
        evaluationId: 'task-eval-2'
      }
    }
  ];

  const mockTaskEvaluations: IEvaluation[] = [
    {
      id: 'task-eval-1',
      taskId: 'task-1',
      userId: 'user-123',
      mode: 'pbl',
      evaluationType: 'formative',
      score: 80,
      feedbackText: 'Good understanding',
      maxScore: 100,
      domainScores: {},
      feedbackData: {},
      aiProvider: 'vertex-ai',
      aiModel: 'gemini-2.5-flash',
      aiAnalysis: {},
      timeTakenSeconds: 600,
      pblData: {},
      discoveryData: {},
      assessmentData: {},
      createdAt: '2024-01-01T00:00:00Z',
      metadata: {
        feedbackText: 'Well done on this task',
        strengths: ['Clear thinking', 'Good examples'],
        improvements: ['Could elaborate more']
      }
    },
    {
      id: 'task-eval-2',
      taskId: 'task-2',
      userId: 'user-123',
      mode: 'pbl',
      evaluationType: 'formative',
      score: 90,
      feedbackText: 'Excellent work',
      maxScore: 100,
      domainScores: {},
      feedbackData: {},
      aiProvider: 'vertex-ai',
      aiModel: 'gemini-2.5-flash',
      aiAnalysis: {},
      timeTakenSeconds: 450,
      pblData: {},
      discoveryData: {},
      assessmentData: {},
      createdAt: '2024-01-01T00:00:00Z',
      metadata: {
        feedbackText: 'Excellent interaction with AI',
        strengths: ['Great questions', 'Applied knowledge well'],
        improvements: ['Consider edge cases']
      }
    }
  ];

  // Get the mock function from the mocked module
  const mockVertexAI = require('@google-cloud/vertexai');
  const mockGenerateContent = mockVertexAI.__mockGenerateContent;
  
  // Get the language mock
  const { getLanguageFromHeader } = require('@/lib/utils/language');

  // Mock fetch for complete API call
  const mockFetch = jest.fn();
  global.fetch = mockFetch;

  beforeEach(() => {
    jest.clearAllMocks();
    process.env.GOOGLE_CLOUD_PROJECT = 'test-project';

    // Vertex AI is already mocked at module level

    // Default mock implementations
    (getServerSession as jest.Mock).mockResolvedValue({
      user: { email: 'test@example.com' }
    });
    mockUserRepo.findByEmail.mockResolvedValue(mockUser);
    mockProgramRepo.findById.mockResolvedValue(mockProgram);
    mockEvalRepo.findById.mockResolvedValue(mockEvaluation);
    mockTaskRepo.findByProgram.mockResolvedValue(mockTasks);
    mockScenarioRepo.findById.mockResolvedValue(mockScenario);

    // Setup task evaluation sequence
    mockEvalRepo.findById.mockImplementation((id: string) => {
      if (id === 'eval-123') {
        return Promise.resolve(mockEvaluation);
      }
      if (id === 'task-eval-1') {
        return Promise.resolve(mockTaskEvaluations[0]);
      }
      if (id === 'task-eval-2') {
        return Promise.resolve(mockTaskEvaluations[1]);
      }
      return Promise.resolve(null);
    });

    // Mock AI response
    mockGenerateContent.mockResolvedValue({
      response: {
        candidates: [{
          content: {
            parts: [{
              text: JSON.stringify({
                overallAssessment: 'Good performance overall',
                strengths: [{
                  area: 'Problem Solving',
                  description: 'Demonstrated clear analytical thinking',
                  example: 'Asked relevant questions about AI capabilities'
                }],
                areasForImprovement: [{
                  area: 'Critical Analysis',
                  description: 'Could improve depth of analysis',
                  suggestion: 'Try to consider multiple perspectives'
                }],
                nextSteps: ['Practice with more complex scenarios', 'Explore advanced AI concepts'],
                encouragement: 'Great work! Keep exploring AI literacy concepts.'
              })
            }]
          }
        }]
      }
    });
  });

  afterEach(() => {
    mockError.mockClear();
    mockLog.mockClear();
    delete process.env.GOOGLE_CLOUD_PROJECT;
  });

  describe('Request Validation', () => {
    it('should return 400 when missing programId', async () => {
      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(400);
      expect(data.error).toBe('Missing required parameters');
      expect(data.success).toBe(false);
    });

    it('should return 400 when missing scenarioId', async () => {
      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(400);
      expect(data.error).toBe('Missing required parameters');
      expect(data.success).toBe(false);
    });

    it('should return 400 when missing both required parameters', async () => {
      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({})
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(400);
      expect(data.error).toBe('Missing required parameters');
      expect(data.success).toBe(false);
    });
  });

  describe('Authentication', () => {
    it('should return 401 when not authenticated', async () => {
      (getServerSession as jest.Mock).mockResolvedValue(null);

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(401);
      expect(data.error).toBe('Authentication required');
      expect(data.success).toBe(false);
    });

    it('should return 401 when session has no user email', async () => {
      (getServerSession as jest.Mock).mockResolvedValue({ user: {} });

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(401);
      expect(data.error).toBe('Authentication required');
      expect(data.success).toBe(false);
    });

    it('should return 404 when user not found', async () => {
      mockUserRepo.findByEmail.mockResolvedValue(null);

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(404);
      expect(data.error).toBe('User not found');
      expect(data.success).toBe(false);
    });
  });

  describe('Program and Ownership Validation', () => {
    it('should return 404 when program not found', async () => {
      mockProgramRepo.findById.mockResolvedValue(null);

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'invalid-program',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(404);
      expect(data.error).toBe('Program not found');
      expect(data.success).toBe(false);
    });

    it('should return 403 when user does not own program', async () => {
      const otherUserProgram = { ...mockProgram, userId: 'other-user' };
      mockProgramRepo.findById.mockResolvedValue(otherUserProgram);

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(403);
      expect(data.error).toBe('Access denied');
      expect(data.success).toBe(false);
    });
  });

  describe('Basic Feedback Generation', () => {
    it('should generate feedback successfully', async () => {
      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      // Tests should pass now that Vertex AI is properly mocked

      expect(response.status).toBe(200);
      expect(data.success).toBe(true);
      expect(data.cached).toBe(false);
      expect(data.language).toBe('en');
      expect(data.feedback).toEqual(expect.objectContaining({
        overallAssessment: expect.any(String),
        strengths: expect.arrayContaining([
          expect.objectContaining({
            area: expect.any(String),
            description: expect.any(String),
            example: expect.any(String)
          })
        ]),
        areasForImprovement: expect.arrayContaining([
          expect.objectContaining({
            area: expect.any(String),
            description: expect.any(String),
            suggestion: expect.any(String)
          })
        ]),
        nextSteps: expect.arrayContaining([expect.any(String)]),
        encouragement: expect.any(String)
      }));
    });

    it('should use English by default', async () => {
      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.language).toBe('en');
      
      const generatedPrompt = mockGenerateContent.mock.calls[0][0].contents[0].parts[0].text;
      expect(generatedPrompt).toContain('English language');
    });

    it('should support Traditional Chinese', async () => {
      // Mock the language function to return zhTW
      (getLanguageFromHeader as jest.Mock).mockReturnValue('zhTW');
      
      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.language).toBe('zhTW');
      
      const generatedPrompt = mockGenerateContent.mock.calls[0][0].contents[0].parts[0].text;
      expect(generatedPrompt).toContain('繁體中文');
      
      // Reset the mock
      (getLanguageFromHeader as jest.Mock).mockReturnValue('en');
    });
  });

  describe('Feedback Caching', () => {
    it('should return cached feedback when valid', async () => {
      const evaluationWithCachedFeedback = {
        ...mockEvaluation,
        metadata: {
          ...mockEvaluation.metadata,
          qualitativeFeedback: {
            en: {
              content: {
                overallAssessment: 'Cached assessment',
                strengths: [{ area: 'Test', description: 'Cached strength', example: 'Example' }],
                areasForImprovement: [{ area: 'Test', description: 'Cached improvement', suggestion: 'Suggestion' }],
                nextSteps: ['Cached step'],
                encouragement: 'Cached encouragement'
              },
              isValid: true,
              generatedAt: '2024-01-01T00:00:00Z',
              evaluationVersion: '2024-01-01T00:00:00Z'
            }
          }
        }
      };
      mockEvalRepo.findById.mockImplementation((id: string) => {
        if (id === 'eval-123') return Promise.resolve(evaluationWithCachedFeedback);
        return Promise.resolve(null);
      });

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.cached).toBe(true);
      expect(data.feedback.overallAssessment).toBe('Cached assessment');
      expect(mockGenerateContent).not.toHaveBeenCalled();
    });

    it('should regenerate feedback when forceRegenerate is true', async () => {
      const evaluationWithCachedFeedback = {
        ...mockEvaluation,
        metadata: {
          ...mockEvaluation.metadata,
          qualitativeFeedback: {
            en: {
              content: { overallAssessment: 'Old feedback' },
              isValid: true,
              generatedAt: '2024-01-01T00:00:00Z'
            }
          }
        }
      };
      
      // First call returns cached evaluation, update call changes it
      let callCount = 0;
      mockEvalRepo.findById.mockImplementation((id: string) => {
        callCount++;
        if (id === 'eval-123') {
          if (callCount === 1) {
            return Promise.resolve(evaluationWithCachedFeedback);
          }
          // After update, return modified evaluation
          return Promise.resolve({
            ...evaluationWithCachedFeedback,
            metadata: {
              ...evaluationWithCachedFeedback.metadata,
              qualitativeFeedback: {
                en: {
                  content: { overallAssessment: 'Old feedback' },
                  isValid: false,
                  generatedAt: '2024-01-01T00:00:00Z'
                }
              }
            }
          });
        }
        return Promise.resolve(null);
      });

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123',
          forceRegenerate: true
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.cached).toBe(false);
      expect(mockEvalRepo.update).toHaveBeenCalled();
      expect(mockGenerateContent).toHaveBeenCalled();
    });
  });

  describe('Error Handling', () => {
    it('should handle repository errors gracefully', async () => {
      mockProgramRepo.findById.mockRejectedValue(new Error('Database connection failed'));

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(500);
      expect(data.error).toBe('Failed to generate feedback');
      expect(data.success).toBe(false);
      expect(mockError).toHaveBeenCalledWith('Error generating feedback:', expect.any(Error));
    });

    it('should handle invalid JSON body', async () => {
      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: 'invalid json'
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(500);
      expect(data.error).toBe('Failed to generate feedback');
      expect(data.success).toBe(false);
    });

    it('should handle empty AI response candidates', async () => {
      // Mock generateContent to return empty candidates
      mockGenerateContent.mockResolvedValueOnce({
        response: {
          candidates: []
        }
      });

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.success).toBe(true);
      expect(data.feedback).toBeDefined();
      
      // Empty candidates result in '{}' which parses to empty object
      // The route handles this by checking if feedback is falsy and using fallback
      // But {} is truthy, so we should expect the empty object behavior
      // OR the route should have additional validation
      expect(typeof data.feedback).toBe('object');
    });

    it('should handle AI response with null text', async () => {
      // Mock generateContent to return null text
      mockGenerateContent.mockResolvedValueOnce({
        response: {
          candidates: [{
            content: {
              parts: [{
                text: null
              }]
            }
          }]
        }
      });

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      // null text becomes '{}' and parses to empty object, which is handled gracefully
      expect(response.status).toBe(200);
      expect(data.success).toBe(true);
      expect(data.feedback).toBeDefined();
      expect(typeof data.feedback).toBe('object');
    });

    it('should handle JSON parsing errors gracefully', async () => {
      // Override the default mock for this test - completely invalid JSON that can't be repaired
      mockGenerateContent.mockResolvedValueOnce({
        response: {
          candidates: [{
            content: {
              parts: [{
                text: 'completely invalid json'
              }]
            }
          }]
        }
      });

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      // When JSON is completely unparseable, it should fail gracefully
      expect(response.status).toBe(500);
      expect(data.success).toBe(false);
      expect(data.error).toBe('Failed to generate feedback');
    });

  });

  describe('AI Configuration', () => {
    it('should configure Vertex AI correctly', async () => {
      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      await POST(request);

      // Since VertexAI is instantiated at module level, just verify the AI call was made correctly
      expect(mockGenerateContent).toHaveBeenCalledWith(
        expect.objectContaining({
          contents: expect.arrayContaining([
            expect.objectContaining({
              role: 'user',
              parts: expect.arrayContaining([
                expect.objectContaining({
                  text: expect.stringContaining('AI Literacy Scenario')
                })
              ])
            })
          ]),
          generationConfig: expect.objectContaining({
            temperature: 0.7,
            maxOutputTokens: 65535,
            responseMimeType: 'application/json',
            responseSchema: expect.any(Object)
          })
        })
      );
    });

    it('should handle Vertex AI errors', async () => {
      mockGenerateContent.mockRejectedValue(new Error('AI service unavailable'));

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(500);
      expect(data.error).toBe('Failed to generate feedback');
      expect(data.success).toBe(false);
      expect(mockError).toHaveBeenCalledWith('Error generating feedback:', expect.any(Error));
    });
  });

  describe('Evaluation Creation Flow', () => {
    it('should create evaluation when not found', async () => {
      const programWithoutEval = { ...mockProgram, metadata: {} };
      mockProgramRepo.findById.mockResolvedValue(programWithoutEval);
      
      // Mock evaluation not found initially
      let findCallCount = 0;
      mockEvalRepo.findById.mockImplementation((id: string) => {
        findCallCount++;
        if (id === 'eval-123' && findCallCount === 1) {
          return Promise.resolve(null); // Not found initially
        }
        return Promise.resolve(null);
      });

      // Mock complete API success
      mockFetch.mockResolvedValue({
        ok: true,
        json: async () => ({
          success: true,
          evaluation: mockEvaluation
        })
      });

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/pbl/programs/program-123/complete'),
        expect.objectContaining({
          method: 'POST'
        })
      );
      expect(data.success).toBe(true);
    });

    it('should return 500 when complete API fails', async () => {
      const programWithoutEval = { ...mockProgram, metadata: {} };
      mockProgramRepo.findById.mockResolvedValue(programWithoutEval);
      mockEvalRepo.findById.mockResolvedValue(null);

      // Mock complete API failure
      mockFetch.mockResolvedValue({
        ok: false,
        status: 500
      });

      const request = new NextRequest('http://localhost/api/pbl/generate-feedback', {
        method: 'POST',
        body: JSON.stringify({
          programId: 'program-123',
          scenarioId: 'scenario-123'
        })
      });
      
      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(500);
      expect(data.error).toBe('Failed to create program evaluation');
      expect(data.success).toBe(false);
    });
  });
});