# üî∫ Ê∏¨Ë©¶ÈáëÂ≠óÂ°îÂØ¶‰ΩúÊåáÂçó - Integration Tests Â±§

> üìÖ Last Updated: 2025-08-11  
> üìä Current Coverage: 76.59% ‚Üí Target: 82%+  
> üë∑ Implementation Time: ~10 hours  
> üéØ Priority: HIGH - Critical for quality assurance

## üìã Executive Summary

Êú¨ÊåáÂçóÊèê‰æõÂÆåÊï¥ÁöÑ Integration Test ÂØ¶‰ΩúÊñπÊ≥ïÔºåÂπ´Âä©Â∑•Á®ãÂúòÈöäÂæûÁï∂Ââç 76.59% Ë¶ÜËìãÁéáÊèêÂçáËá≥ 82%+„ÄÇIntegration Tests ÊòØÊ∏¨Ë©¶ÈáëÂ≠óÂ°îÁöÑ‰∏≠ÈñìÂ±§ÔºåÊèê‰æõÊúÄÈ´òÁöÑÊäïË≥áÂ†±ÈÖ¨Áéá„ÄÇ

### ÁÇ∫‰ªÄÈ∫ºÊòØ Integration TestsÔºü
- **CPÂÄºÊúÄÈ´ò**: ËºÉÂ∞ëÁöÑÊ∏¨Ë©¶Ë¶ÜËìãËºÉÂ§öÁöÑÁ®ãÂºèÁ¢º
- **ÊçïÊçâÁúüÂØ¶ÂïèÈ°å**: Unit tests ÁÑ°Ê≥ïÁôºÁèæÁöÑÊï¥ÂêàÂïèÈ°å
- **Ê•≠ÂãôÂÉπÂÄº**: È©óË≠âÂÆåÊï¥ÁöÑ‰ΩøÁî®ËÄÖÊóÖÁ®ã

## üèóÔ∏è Êû∂ÊßãË®≠Ë®à

```
frontend/
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ setup/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test-environment.ts      # Ê∏¨Ë©¶Áí∞Â¢ÉË®≠ÂÆö
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test-fixtures.ts         # Ê∏¨Ë©¶Ë≥áÊñô
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test-helpers.ts          # ËºîÂä©ÂáΩÊï∏
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ global-setup.ts          # Jest ÂÖ®ÂüüË®≠ÂÆö
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ flows/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ complete-learning-journey.test.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-onboarding.test.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cross-module-integration.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cache/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cache-consistency.test.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cache-invalidation.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ performance/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ load-test.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ concurrent-users.test.ts
‚îú‚îÄ‚îÄ jest.integration.config.js           # Jest Ë®≠ÂÆö
‚îî‚îÄ‚îÄ package.json                          # NPM scripts
```

## üõ†Ô∏è Step 1: Âª∫Á´ãÊ∏¨Ë©¶Âü∫Á§éË®≠ÊñΩ

### 1.1 Ê∏¨Ë©¶Áí∞Â¢ÉÁÆ°ÁêÜÂô®

**üìÅ `/frontend/tests/integration/setup/test-environment.ts`**

```typescript
import { Pool } from 'pg';
import Redis from 'ioredis';
import { repositoryFactory } from '@/lib/repositories/factory/repository-factory';
import * as fs from 'fs';
import * as path from 'path';

export class IntegrationTestEnvironment {
  private dbPool: Pool;
  private redisClient: Redis;
  private testDbName: string;
  private isSetup: boolean = false;

  constructor() {
    // ‰ΩøÁî®ÊôÇÈñìÊà≥Á¢∫‰øùÂîØ‰∏ÄÊÄß
    this.testDbName = `test_db_${Date.now()}_${process.pid}`;
  }

  async setup() {
    if (this.isSetup) return;
    
    console.log(`üöÄ Setting up test environment: ${this.testDbName}`);
    
    try {
      // 1. ÂâµÂª∫Ê∏¨Ë©¶Ë≥áÊñôÂ∫´
      await this.createTestDatabase();
      
      // 2. Âü∑Ë°å migrations
      await this.runMigrations();
      
      // 3. Ë®≠ÁΩÆ Redis Ê∏¨Ë©¶ÂØ¶‰æã
      await this.setupRedis();
      
      // 4. ÂàùÂßãÂåñ repositories
      await this.initializeRepositories();
      
      // 5. Ë®≠ÁΩÆÁí∞Â¢ÉËÆäÊï∏
      this.setupEnvironmentVariables();
      
      this.isSetup = true;
      console.log('‚úÖ Test environment ready');
    } catch (error) {
      console.error('‚ùå Setup failed:', error);
      await this.teardown();
      throw error;
    }
  }

  async teardown() {
    console.log('üßπ Cleaning up test environment');
    
    try {
      // ÈóúÈñâÈÄ£Á∑ö
      if (this.dbPool) await this.dbPool.end();
      if (this.redisClient) {
        await this.redisClient.flushdb();
        await this.redisClient.quit();
      }
      
      // Âà™Èô§Ê∏¨Ë©¶Ë≥áÊñôÂ∫´
      await this.dropTestDatabase();
      
      console.log('‚úÖ Cleanup complete');
    } catch (error) {
      console.error('‚ö†Ô∏è Cleanup error:', error);
    }
  }

  private async createTestDatabase() {
    const adminPool = new Pool({
      host: process.env.TEST_DB_HOST || 'localhost',
      port: parseInt(process.env.TEST_DB_PORT || '5433'),
      database: 'postgres',
      user: 'postgres',
      password: 'postgres',
    });

    // Ê™¢Êü•‰∏¶Âà™Èô§Â∑≤Â≠òÂú®ÁöÑÊ∏¨Ë©¶Ë≥áÊñôÂ∫´
    await adminPool.query(
      `DROP DATABASE IF EXISTS ${this.testDbName}`
    );
    
    await adminPool.query(
      `CREATE DATABASE ${this.testDbName}`
    );
    
    await adminPool.end();

    // ÈÄ£Êé•Âà∞Êñ∞Ë≥áÊñôÂ∫´
    this.dbPool = new Pool({
      host: process.env.TEST_DB_HOST || 'localhost',
      port: parseInt(process.env.TEST_DB_PORT || '5433'),
      database: this.testDbName,
      user: 'postgres',
      password: 'postgres',
    });
  }

  private async runMigrations() {
    const schemaPath = path.join(
      process.cwd(), 
      'scripts/schema-v4.sql'
    );
    
    const sql = fs.readFileSync(schemaPath, 'utf8');
    
    // ÂàÜÂâ≤ SQL Ë™ûÂè•‰∏¶Âü∑Ë°å
    const statements = sql
      .split(';')
      .filter(stmt => stmt.trim().length > 0);
    
    for (const statement of statements) {
      await this.dbPool.query(statement);
    }
  }

  private async setupRedis() {
    this.redisClient = new Redis({
      host: process.env.TEST_REDIS_HOST || 'localhost',
      port: parseInt(process.env.TEST_REDIS_PORT || '6379'),
      db: 1, // ‰ΩøÁî®‰∏çÂêåÁöÑ db index ÈÅøÂÖçË°ùÁ™Å
    });
    
    await this.redisClient.flushdb();
  }

  private async initializeRepositories() {
    // Ë®≠ÂÆöÊ∏¨Ë©¶Ë≥áÊñôÂ∫´ÈÄ£Á∑ö
    process.env.DB_HOST = 'localhost';
    process.env.DB_PORT = '5433';
    process.env.DB_NAME = this.testDbName;
    process.env.DB_USER = 'postgres';
    process.env.DB_PASSWORD = 'postgres';
    
    // ÈáçÊñ∞ÂàùÂßãÂåñ repository factory
    await repositoryFactory.initialize();
  }

  private setupEnvironmentVariables() {
    process.env.NODE_ENV = 'test';
    process.env.REDIS_ENABLED = 'true';
    process.env.REDIS_URL = 'redis://localhost:6379/1';
    process.env.NEXTAUTH_URL = 'http://localhost:3000';
    process.env.NEXTAUTH_SECRET = 'test-secret';
  }

  private async dropTestDatabase() {
    const adminPool = new Pool({
      host: process.env.TEST_DB_HOST || 'localhost',
      port: parseInt(process.env.TEST_DB_PORT || '5433'),
      database: 'postgres',
      user: 'postgres',
      password: 'postgres',
    });

    // Âº∑Âà∂Êñ∑ÈñãÈÄ£Á∑ö
    await adminPool.query(`
      SELECT pg_terminate_backend(pid)
      FROM pg_stat_activity
      WHERE datname = '${this.testDbName}'
        AND pid <> pg_backend_pid()
    `);
    
    await adminPool.query(
      `DROP DATABASE IF EXISTS ${this.testDbName}`
    );
    
    await adminPool.end();
  }

  // Getters for test access
  getDbPool() { return this.dbPool; }
  getRedisClient() { return this.redisClient; }
  getTestDbName() { return this.testDbName; }
}
```

### 1.2 Ê∏¨Ë©¶Ë≥áÊñô Fixtures

**üìÅ `/frontend/tests/integration/setup/test-fixtures.ts`**

```typescript
import { v4 as uuidv4 } from 'uuid';
import bcrypt from 'bcryptjs';

export const testFixtures = {
  // Ê∏¨Ë©¶Áî®Êà∂
  users: {
    student: {
      id: uuidv4(),
      email: 'student@test.com',
      password: 'Test123!@#',
      passwordHash: bcrypt.hashSync('Test123!@#', 10),
      name: 'Test Student',
      role: 'user',
      emailVerified: true
    },
    teacher: {
      id: uuidv4(),
      email: 'teacher@test.com',
      password: 'Test123!@#',
      passwordHash: bcrypt.hashSync('Test123!@#', 10),
      name: 'Test Teacher',
      role: 'teacher',
      emailVerified: true
    },
    unverified: {
      id: uuidv4(),
      email: 'unverified@test.com',
      password: 'Test123!@#',
      passwordHash: bcrypt.hashSync('Test123!@#', 10),
      name: 'Unverified User',
      role: 'user',
      emailVerified: false
    }
  },
  
  // PBL Ê∏¨Ë©¶ÊÉÖÂ¢É
  scenarios: {
    pbl: {
      id: uuidv4(),
      mode: 'pbl',
      status: 'active',
      sourceType: 'test',
      sourcePath: 'test/pbl-scenario',
      title: { 
        en: 'Test PBL Scenario',
        zh: 'Ê∏¨Ë©¶ PBL ÊÉÖÂ¢É'
      },
      description: { 
        en: 'Integration test PBL scenario',
        zh: 'Êï¥ÂêàÊ∏¨Ë©¶ PBL ÊÉÖÂ¢É'
      },
      objectives: [
        'Learn AI basics',
        'Apply knowledge'
      ],
      taskTemplates: [
        {
          id: 'task-1',
          index: 0,
          title: { en: 'Understanding AI' },
          type: 'question',
          content: {
            instructions: 'Answer the following question',
            question: 'What is artificial intelligence?',
            hints: ['Think about machine learning']
          },
          estimatedTime: 5
        },
        {
          id: 'task-2',
          index: 1,
          title: { en: 'AI Applications' },
          type: 'creation',
          content: {
            instructions: 'Create an AI use case',
            requirements: ['Be specific', 'Include benefits']
          },
          estimatedTime: 10
        }
      ],
      pblData: {
        difficulty: 'intermediate',
        prerequisites: [],
        learningOutcomes: ['AI understanding'],
        ksaCodes: {
          knowledge: ['K1.1', 'K1.2'],
          skills: ['S2.1'],
          attitudes: ['A3.1']
        }
      }
    },
    
    assessment: {
      id: uuidv4(),
      mode: 'assessment',
      status: 'active',
      sourceType: 'test',
      sourcePath: 'test/assessment',
      title: { 
        en: 'AI Literacy Assessment',
        zh: 'AI Á¥†È§äË©ï‰º∞'
      },
      description: { 
        en: 'Test your AI knowledge',
        zh: 'Ê∏¨Ë©¶ÊÇ®ÁöÑ AI Áü•Ë≠ò'
      },
      assessmentData: {
        totalQuestions: 10,
        timeLimitMinutes: 30,
        passingScore: 70,
        questions: [
          {
            id: 'q1',
            question: { en: 'What is machine learning?' },
            options: [
              { en: 'A type of AI' },
              { en: 'A database' },
              { en: 'A programming language' },
              { en: 'A hardware device' }
            ],
            correctAnswer: 0,
            domain: 'Engaging_with_AI'
          }
        ]
      }
    },
    
    discovery: {
      id: uuidv4(),
      mode: 'discovery',
      status: 'active',
      sourceType: 'test',
      sourcePath: 'test/discovery',
      title: { 
        en: 'AI Career Explorer',
        zh: 'AI ËÅ∑Ê∂ØÊé¢Á¥¢'
      },
      description: { 
        en: 'Explore AI career paths',
        zh: 'Êé¢Á¥¢ AI ËÅ∑Ê∂ØË∑ØÂæë'
      },
      discoveryData: {
        careerType: 'data_scientist',
        requiredSkills: ['Python', 'Statistics', 'ML'],
        relatedPaths: ['ml_engineer', 'data_analyst'],
        milestones: [
          {
            id: 'milestone-1',
            title: 'Learn Python',
            description: 'Master Python programming',
            completed: false
          }
        ]
      }
    }
  },
  
  // Ê∏¨Ë©¶ API responses
  responses: {
    aiEvaluation: {
      score: 85,
      feedback: 'Great understanding of AI concepts',
      strengths: ['Clear explanation', 'Good examples'],
      improvements: ['Add more details'],
      ksaScores: {
        knowledge: 90,
        skills: 80,
        attitudes: 85
      }
    }
  }
};
```

### 1.3 Ê∏¨Ë©¶ËºîÂä©ÂáΩÊï∏

**üìÅ `/frontend/tests/integration/setup/test-helpers.ts`**

```typescript
import { Pool } from 'pg';
import jwt from 'jsonwebtoken';
import { testFixtures } from './test-fixtures';

export class TestHelpers {
  constructor(private dbPool: Pool) {}

  // ÂâµÂª∫Ê∏¨Ë©¶Áî®Êà∂
  async createUser(userData = testFixtures.users.student) {
    const result = await this.dbPool.query(
      `INSERT INTO users (id, email, password_hash, name, role, email_verified)
       VALUES ($1, $2, $3, $4, $5, $6)
       RETURNING *`,
      [
        userData.id,
        userData.email,
        userData.passwordHash,
        userData.name,
        userData.role,
        userData.emailVerified
      ]
    );
    return result.rows[0];
  }

  // ÁîüÊàê JWT token
  generateAuthToken(userId: string) {
    return jwt.sign(
      { userId, email: 'test@example.com' },
      process.env.NEXTAUTH_SECRET || 'test-secret',
      { expiresIn: '1h' }
    );
  }

  // ÂâµÂª∫Ê∏¨Ë©¶ scenario
  async createScenario(scenarioData = testFixtures.scenarios.pbl) {
    const result = await this.dbPool.query(
      `INSERT INTO scenarios 
       (id, mode, status, source_type, source_path, title, description, 
        objectives, task_templates, pbl_data, discovery_data, assessment_data)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
       RETURNING *`,
      [
        scenarioData.id,
        scenarioData.mode,
        scenarioData.status,
        scenarioData.sourceType,
        scenarioData.sourcePath,
        JSON.stringify(scenarioData.title),
        JSON.stringify(scenarioData.description),
        JSON.stringify(scenarioData.objectives),
        JSON.stringify(scenarioData.taskTemplates),
        scenarioData.pblData ? JSON.stringify(scenarioData.pblData) : null,
        scenarioData.discoveryData ? JSON.stringify(scenarioData.discoveryData) : null,
        scenarioData.assessmentData ? JSON.stringify(scenarioData.assessmentData) : null
      ]
    );
    return result.rows[0];
  }

  // ÂâµÂª∫ program
  async createProgram(userId: string, scenarioId: string) {
    const result = await this.dbPool.query(
      `INSERT INTO programs (user_id, scenario_id, status, mode)
       VALUES ($1, $2, 'active', 
         (SELECT mode FROM scenarios WHERE id = $2))
       RETURNING *`,
      [userId, scenarioId]
    );
    return result.rows[0];
  }

  // Ê∏ÖÁêÜÊ∏¨Ë©¶Ë≥áÊñô
  async cleanup() {
    await this.dbPool.query('TRUNCATE TABLE users CASCADE');
    await this.dbPool.query('TRUNCATE TABLE scenarios CASCADE');
    await this.dbPool.query('TRUNCATE TABLE programs CASCADE');
    await this.dbPool.query('TRUNCATE TABLE tasks CASCADE');
    await this.dbPool.query('TRUNCATE TABLE evaluations CASCADE');
  }

  // Á≠âÂæÖÊ¢ù‰ª∂ÊàêÁ´ã
  async waitFor(
    condition: () => Promise<boolean>,
    timeout = 5000,
    interval = 100
  ): Promise<void> {
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      if (await condition()) {
        return;
      }
      await new Promise(resolve => setTimeout(resolve, interval));
    }
    
    throw new Error('Timeout waiting for condition');
  }

  // È©óË≠âÂø´ÂèñÁãÄÊÖã
  async verifyCacheState(key: string, expectedValue: any) {
    const cacheValue = await this.getCacheValue(key);
    expect(cacheValue).toEqual(expectedValue);
  }

  // ÂèñÂæóÂø´ÂèñÂÄº
  async getCacheValue(key: string) {
    // ÂØ¶‰ΩúÂø´ÂèñËÆÄÂèñÈÇèËºØ
    return null;
  }
}
```

## üß™ Step 2: Ê†∏ÂøÉÂ≠∏ÁøíÊµÅÁ®ãÊï¥ÂêàÊ∏¨Ë©¶

### 2.1 ÂÆåÊï¥Â≠∏ÁøíÊóÖÁ®ãÊ∏¨Ë©¶

**üìÅ `/frontend/tests/integration/flows/complete-learning-journey.test.ts`**

```typescript
import { IntegrationTestEnvironment } from '../setup/test-environment';
import { TestHelpers } from '../setup/test-helpers';
import { testFixtures } from '../setup/test-fixtures';
import request from 'supertest';
import { createServer } from 'http';
import { parse } from 'url';
import next from 'next';

describe('Complete Learning Journey Integration', () => {
  let env: IntegrationTestEnvironment;
  let helpers: TestHelpers;
  let app: any;
  let server: any;
  let authToken: string;
  let userId: string;
  let programId: string;
  let scenarioId: string;

  beforeAll(async () => {
    // ÂàùÂßãÂåñÊ∏¨Ë©¶Áí∞Â¢É
    env = new IntegrationTestEnvironment();
    await env.setup();
    
    helpers = new TestHelpers(env.getDbPool());
    
    // ÂïüÂãï Next.js Ê∏¨Ë©¶ server
    const nextApp = next({ dev: false, dir: process.cwd() });
    const handle = nextApp.getRequestHandler();
    await nextApp.prepare();
    
    server = createServer((req, res) => {
      const parsedUrl = parse(req.url!, true);
      handle(req, res, parsedUrl);
    });
    
    await new Promise(resolve => {
      server.listen(0, resolve);
    });
    
    app = `http://localhost:${server.address().port}`;
  }, 30000);

  afterAll(async () => {
    server?.close();
    await helpers.cleanup();
    await env.teardown();
  });

  describe('User Registration to Completion Flow', () => {
    test('1. User can register and verify email', async () => {
      // Ë®ªÂÜäÊñ∞Áî®Êà∂
      const registerRes = await request(app)
        .post('/api/auth/register')
        .send({
          email: 'newuser@test.com',
          password: 'Test123!@#',
          name: 'New Test User'
        });

      expect(registerRes.status).toBe(201);
      expect(registerRes.body.user).toBeDefined();
      expect(registerRes.body.user.email).toBe('newuser@test.com');
      userId = registerRes.body.user.id;

      // ÂæûË≥áÊñôÂ∫´ÂèñÂæóÈ©óË≠â token
      const tokenResult = await env.getDbPool().query(
        `SELECT token FROM verification_tokens WHERE user_id = $1`,
        [userId]
      );
      const verificationToken = tokenResult.rows[0].token;

      // È©óË≠â email
      const verifyRes = await request(app)
        .post('/api/auth/verify-email')
        .send({ token: verificationToken });

      expect(verifyRes.status).toBe(200);
      expect(verifyRes.body.verified).toBe(true);
      
      // Á¢∫Ë™çË≥áÊñôÂ∫´Â∑≤Êõ¥Êñ∞
      const userResult = await env.getDbPool().query(
        `SELECT email_verified FROM users WHERE id = $1`,
        [userId]
      );
      expect(userResult.rows[0].email_verified).toBe(true);
    });

    test('2. User can login and get session', async () => {
      const loginRes = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'newuser@test.com',
          password: 'Test123!@#'
        });

      expect(loginRes.status).toBe(200);
      expect(loginRes.body.token).toBeDefined();
      authToken = loginRes.body.token;
      
      // È©óË≠â session Â≠òÂú®
      const sessionRes = await request(app)
        .get('/api/auth/session')
        .set('Authorization', `Bearer ${authToken}`);
        
      expect(sessionRes.status).toBe(200);
      expect(sessionRes.body.user.id).toBe(userId);
      expect(sessionRes.body.user.email).toBe('newuser@test.com');
    });

    test('3. User can start a PBL program', async () => {
      // ÂâµÂª∫Ê∏¨Ë©¶ scenario
      const scenario = await helpers.createScenario(
        testFixtures.scenarios.pbl
      );
      scenarioId = scenario.id;
      
      // ÈñãÂßã program
      const startRes = await request(app)
        .post(`/api/pbl/scenarios/${scenarioId}/start`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({ language: 'en' });

      expect(startRes.status).toBe(201);
      expect(startRes.body.program).toBeDefined();
      programId = startRes.body.program.id;
      
      // È©óË≠â program ÁãÄÊÖã
      expect(startRes.body.program.status).toBe('active');
      expect(startRes.body.program.userId).toBe(userId);
      expect(startRes.body.program.scenarioId).toBe(scenarioId);
      
      // È©óË≠âË≥áÊñôÂ∫´
      const programResult = await env.getDbPool().query(
        `SELECT * FROM programs WHERE id = $1`,
        [programId]
      );
      expect(programResult.rows[0].status).toBe('active');
      expect(programResult.rows[0].started_at).toBeDefined();
    });

    test('4. User can complete tasks', async () => {
      // ÂèñÂæó‰ªªÂãôÂàóË°®
      const tasksRes = await request(app)
        .get(`/api/pbl/programs/${programId}/tasks`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(tasksRes.status).toBe(200);
      const tasks = tasksRes.body.tasks;
      expect(tasks.length).toBeGreaterThan(0);

      // ÂÆåÊàêÁ¨¨‰∏ÄÂÄã‰ªªÂãô
      const taskId = tasks[0].id;
      const completeTaskRes = await request(app)
        .post(`/api/pbl/tasks/${taskId}/complete`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          response: 'AI is artificial intelligence that simulates human intelligence',
          timeSpent: 120
        });

      expect(completeTaskRes.status).toBe(200);
      expect(completeTaskRes.body.evaluation).toBeDefined();
      expect(completeTaskRes.body.evaluation.score).toBeGreaterThan(0);
      
      // È©óË≠â‰ªªÂãôÁãÄÊÖãÂ∑≤Êõ¥Êñ∞
      const taskResult = await env.getDbPool().query(
        `SELECT status, completed_at FROM tasks WHERE id = $1`,
        [taskId]
      );
      expect(taskResult.rows[0].status).toBe('completed');
      expect(taskResult.rows[0].completed_at).toBeDefined();
    });

    test('5. User can complete program and get certificate', async () => {
      // ÂÖàÂÆåÊàêÊâÄÊúâ‰ªªÂãô
      const tasksRes = await request(app)
        .get(`/api/pbl/programs/${programId}/tasks`)
        .set('Authorization', `Bearer ${authToken}`);
      
      const incompleteTasks = tasksRes.body.tasks.filter(
        (t: any) => t.status !== 'completed'
      );
      
      // ÂÆåÊàêÂâ©È§ò‰ªªÂãô
      for (const task of incompleteTasks) {
        await request(app)
          .post(`/api/pbl/tasks/${task.id}/complete`)
          .set('Authorization', `Bearer ${authToken}`)
          .send({
            response: 'Test response for task completion',
            timeSpent: 60
          });
      }

      // ÂÆåÊàê program
      const completeRes = await request(app)
        .post(`/api/pbl/programs/${programId}/complete`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(completeRes.status).toBe(200);
      expect(completeRes.body.certificate).toBeDefined();
      expect(completeRes.body.totalScore).toBeGreaterThan(0);
      expect(completeRes.body.achievements).toBeInstanceOf(Array);
      
      // È©óË≠âË≥áÊñôÂ∫´ÁãÄÊÖã
      const programResult = await env.getDbPool().query(
        `SELECT status, completed_at, total_score 
         FROM programs WHERE id = $1`,
        [programId]
      );
      expect(programResult.rows[0].status).toBe('completed');
      expect(programResult.rows[0].completed_at).toBeDefined();
      expect(programResult.rows[0].total_score).toBeGreaterThan(0);
    });
  });

  describe('Cross-Module Integration', () => {
    test('Assessment results affect PBL recommendations', async () => {
      // ÂÆåÊàê assessment
      const assessmentScenario = await helpers.createScenario(
        testFixtures.scenarios.assessment
      );
      
      const assessmentRes = await request(app)
        .post(`/api/assessment/scenarios/${assessmentScenario.id}/complete`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          answers: [0, 1, 2, 0, 1], // Ê∏¨Ë©¶Á≠îÊ°à
          timeSpent: 600
        });
      
      expect(assessmentRes.status).toBe(200);
      const score = assessmentRes.body.score;
      
      // ÂèñÂæóÊé®Ëñ¶ÁöÑ PBL scenarios
      const recommendRes = await request(app)
        .get('/api/pbl/recommendations')
        .set('Authorization', `Bearer ${authToken}`);
      
      expect(recommendRes.status).toBe(200);
      
      // ‰ΩéÂàÜÊáâË©≤Êé®Ëñ¶Âü∫Á§éË™≤Á®ã
      if (score < 50) {
        expect(recommendRes.body.scenarios[0].difficulty).toBe('beginner');
      } else {
        expect(recommendRes.body.scenarios[0].difficulty).toBe('intermediate');
      }
    });

    test('PBL completion unlocks Discovery paths', async () => {
      // Ê™¢Êü• Discovery Ëß£ÈéñÁãÄÊÖã
      const discoveryRes = await request(app)
        .get('/api/discovery/paths')
        .set('Authorization', `Bearer ${authToken}`);
      
      expect(discoveryRes.status).toBe(200);
      
      // È©óË≠âÂõ†ÂÆåÊàê PBL ËÄåËß£ÈéñÁöÑË∑ØÂæë
      const unlockedPaths = discoveryRes.body.paths.filter(
        (p: any) => p.unlocked
      );
      expect(unlockedPaths.length).toBeGreaterThan(0);
    });
  });
});
```

## üöÄ Step 3: Âø´Âèñ‰∏ÄËá¥ÊÄßÊ∏¨Ë©¶

### 3.1 Âø´ÂèñËàáË≥áÊñôÂ∫´ÂêåÊ≠•Ê∏¨Ë©¶

**üìÅ `/frontend/tests/integration/cache/cache-consistency.test.ts`**

```typescript
import { IntegrationTestEnvironment } from '../setup/test-environment';
import { TestHelpers } from '../setup/test-helpers';
import request from 'supertest';
import Redis from 'ioredis';

describe('Cache and Database Consistency', () => {
  let env: IntegrationTestEnvironment;
  let helpers: TestHelpers;
  let redis: Redis;
  let app: string;
  
  beforeAll(async () => {
    env = new IntegrationTestEnvironment();
    await env.setup();
    
    helpers = new TestHelpers(env.getDbPool());
    redis = env.getRedisClient();
    
    // Setup test server
    app = 'http://localhost:3001'; // ÂÅáË®≠Ê∏¨Ë©¶ server Âú®Ê≠§ port
  });

  afterAll(async () => {
    await helpers.cleanup();
    await env.teardown();
  });

  test('Cache invalidation on data update', async () => {
    // 1. ÂâµÂª∫Ê∏¨Ë©¶Ë≥áÊñô
    const scenario = await helpers.createScenario();
    const scenarioId = scenario.id;
    
    // 2. Á¨¨‰∏ÄÊ¨°ËÆÄÂèñ (cache miss)
    const res1 = await request(app)
      .get(`/api/pbl/scenarios/${scenarioId}`)
      .query({ lang: 'en' });
    
    expect(res1.headers['x-cache']).toBe('MISS');
    expect(res1.body.title.en).toBe('Test PBL Scenario');
    
    // 3. Á¨¨‰∫åÊ¨°ËÆÄÂèñ (cache hit)
    const res2 = await request(app)
      .get(`/api/pbl/scenarios/${scenarioId}`)
      .query({ lang: 'en' });
    
    expect(res2.headers['x-cache']).toBe('HIT');
    expect(res2.body.title.en).toBe('Test PBL Scenario');
    
    // 4. Áõ¥Êé•Êõ¥Êñ∞Ë≥áÊñôÂ∫´
    await env.getDbPool().query(
      `UPDATE scenarios 
       SET title = $1
       WHERE id = $2`,
      [
        JSON.stringify({ en: 'Updated Title', zh: 'Êõ¥Êñ∞ÁöÑÊ®ôÈ°å' }),
        scenarioId
      ]
    );
    
    // 5. Ê∏ÖÈô§Âø´Âèñ
    const cacheKey = `scenario:${scenarioId}:en`;
    await redis.del(cacheKey);
    
    // 6. ËÆÄÂèñÊñ∞Ë≥áÊñô (cache miss)
    const res3 = await request(app)
      .get(`/api/pbl/scenarios/${scenarioId}`)
      .query({ lang: 'en' });
    
    expect(res3.headers['x-cache']).toBe('MISS');
    expect(res3.body.title.en).toBe('Updated Title');
    
    // 7. Á¢∫Ë™çÂø´ÂèñÂ∑≤Êõ¥Êñ∞
    const res4 = await request(app)
      .get(`/api/pbl/scenarios/${scenarioId}`)
      .query({ lang: 'en' });
    
    expect(res4.headers['x-cache']).toBe('HIT');
    expect(res4.body.title.en).toBe('Updated Title');
  });

  test('Concurrent updates maintain consistency', async () => {
    const user = await helpers.createUser();
    const token = helpers.generateAuthToken(user.id);
    const scenario = await helpers.createScenario();
    const program = await helpers.createProgram(user.id, scenario.id);
    
    // 10 ÂÄã‰∏¶ÁôºÊõ¥Êñ∞
    const updates = [];
    for (let i = 0; i < 10; i++) {
      updates.push(
        request(app)
          .post(`/api/pbl/programs/${program.id}/update-score`)
          .set('Authorization', `Bearer ${token}`)
          .send({ score: 70 + i })
      );
    }
    
    const results = await Promise.all(updates);
    
    // È©óË≠âÊâÄÊúâÊõ¥Êñ∞ÈÉΩÊàêÂäü
    results.forEach(res => {
      expect(res.status).toBe(200);
    });
    
    // È©óË≠âÊúÄÁµÇÁãÄÊÖã‰∏ÄËá¥
    const dbResult = await env.getDbPool().query(
      `SELECT total_score FROM programs WHERE id = $1`,
      [program.id]
    );
    
    const cacheKey = `program:${program.id}`;
    const cacheValue = await redis.get(cacheKey);
    const cacheData = cacheValue ? JSON.parse(cacheValue) : null;
    
    // Ë≥áÊñôÂ∫´ÂíåÂø´ÂèñÊáâË©≤‰∏ÄËá¥
    expect(cacheData?.totalScore).toBe(dbResult.rows[0].total_score);
  });

  test('Stale-While-Revalidate pattern works correctly', async () => {
    const scenario = await helpers.createScenario();
    const cacheKey = `scenario:${scenario.id}:en`;
    
    // Ë®≠ÂÆöÂø´ÂèñÁÇ∫ stale
    await redis.setex(
      cacheKey,
      1, // 1 ÁßíÂæåÈÅéÊúü
      JSON.stringify({
        ...scenario,
        _stale: false
      })
    );
    
    // Á≠âÂæÖÂø´ÂèñÈÅéÊúü
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    // Ë´ãÊ±ÇÊáâËøîÂõû stale Ë≥áÊñô‰∏¶ËÉåÊôØÊõ¥Êñ∞
    const res = await request(app)
      .get(`/api/pbl/scenarios/${scenario.id}`)
      .query({ lang: 'en' });
    
    expect(res.headers['x-cache']).toBe('STALE');
    
    // Á≠âÂæÖËÉåÊôØÊõ¥Êñ∞ÂÆåÊàê
    await helpers.waitFor(async () => {
      const value = await redis.get(cacheKey);
      return value !== null && !JSON.parse(value)._stale;
    });
    
    // ‰∏ãÊ¨°Ë´ãÊ±ÇÊáâË©≤ÊòØ HIT
    const res2 = await request(app)
      .get(`/api/pbl/scenarios/${scenario.id}`)
      .query({ lang: 'en' });
    
    expect(res2.headers['x-cache']).toBe('HIT');
  });

  test('Cache fallback when Redis is down', async () => {
    // Êö´ÊôÇÈóúÈñâ Redis ÈÄ£Á∑ö
    await redis.quit();
    
    // API ÊáâË©≤‰ªçÁÑ∂ËÉΩÂ∑•‰ΩúÔºàÂæûË≥áÊñôÂ∫´ËÆÄÂèñÔºâ
    const scenario = await helpers.createScenario();
    
    const res = await request(app)
      .get(`/api/pbl/scenarios/${scenario.id}`)
      .query({ lang: 'en' });
    
    expect(res.status).toBe(200);
    expect(res.body.title.en).toBe('Test PBL Scenario');
    
    // ÈáçÊñ∞ÈÄ£Êé• Redis
    redis = new Redis({
      host: 'localhost',
      port: 6379,
      db: 1
    });
  });
});
```

## üìä Step 4: ÊïàËÉΩËàáË≤†ËºâÊ∏¨Ë©¶

### 4.1 ‰∏¶ÁôºÁî®Êà∂Ë≤†ËºâÊ∏¨Ë©¶

**üìÅ `/frontend/tests/integration/performance/load-test.ts`**

```typescript
import { IntegrationTestEnvironment } from '../setup/test-environment';
import { TestHelpers } from '../setup/test-helpers';
import { testFixtures } from '../setup/test-fixtures';
import request from 'supertest';
import { performance } from 'perf_hooks';

describe('Performance and Load Testing', () => {
  let env: IntegrationTestEnvironment;
  let helpers: TestHelpers;
  let app: string;
  let tokens: string[] = [];
  
  beforeAll(async () => {
    env = new IntegrationTestEnvironment();
    await env.setup();
    
    helpers = new TestHelpers(env.getDbPool());
    app = 'http://localhost:3001';
    
    // ÂâµÂª∫Ê∏¨Ë©¶Áî®Êà∂
    for (let i = 0; i < 50; i++) {
      const user = await helpers.createUser({
        ...testFixtures.users.student,
        id: `user-${i}`,
        email: `user${i}@test.com`
      });
      tokens.push(helpers.generateAuthToken(user.id));
    }
    
    // ÂâµÂª∫Ê∏¨Ë©¶Ë≥áÊñô
    await helpers.createScenario();
  });

  afterAll(async () => {
    await helpers.cleanup();
    await env.teardown();
  });

  test('API response time under load', async () => {
    const concurrentUsers = 50;
    const requests = [];
    
    const startTime = performance.now();
    
    // Ê®°Êì¨ 50 ÂÄã‰∏¶ÁôºÁî®Êà∂
    for (let i = 0; i < concurrentUsers; i++) {
      requests.push(
        request(app)
          .get('/api/pbl/scenarios')
          .set('Authorization', `Bearer ${tokens[i]}`)
      );
    }
    
    const responses = await Promise.all(requests);
    const endTime = performance.now();
    
    // Êî∂ÈõÜÈüøÊáâÊôÇÈñì
    const responseTimes = responses.map((res, index) => {
      return {
        status: res.status,
        duration: res.get('X-Response-Time') || 0
      };
    });
    
    // È©óË≠âÊâÄÊúâË´ãÊ±ÇÊàêÂäü
    const successCount = responses.filter(r => r.status === 200).length;
    expect(successCount).toBe(concurrentUsers);
    
    // Ë®àÁÆóÁµ±Ë®à
    const totalTime = endTime - startTime;
    const avgResponseTime = totalTime / concurrentUsers;
    
    // Ë®àÁÆó P95
    const sortedTimes = responseTimes
      .map(r => parseFloat(r.duration))
      .sort((a, b) => a - b);
    const p95Index = Math.floor(sortedTimes.length * 0.95);
    const p95 = sortedTimes[p95Index];
    
    console.log(`
      Performance Results:
      - Total time: ${totalTime.toFixed(2)}ms
      - Average response time: ${avgResponseTime.toFixed(2)}ms
      - P95 response time: ${p95}ms
      - Success rate: ${(successCount/concurrentUsers*100).toFixed(2)}%
    `);
    
    // È©óË≠âÊïàËÉΩÊåáÊ®ô
    expect(avgResponseTime).toBeLessThan(500); // Âπ≥Âùá < 500ms
    expect(p95).toBeLessThan(1000); // P95 < 1s
  });

  test('Cache hit ratio under load', async () => {
    // È†êÁÜ±Âø´Âèñ
    const warmupRequests = [];
    for (let i = 0; i < 10; i++) {
      warmupRequests.push(
        request(app).get('/api/ksa?lang=en')
      );
    }
    await Promise.all(warmupRequests);
    
    // Âü∑Ë°å 100 ÂÄãË´ãÊ±Ç
    const testRequests = [];
    for (let i = 0; i < 100; i++) {
      testRequests.push(
        request(app).get('/api/ksa?lang=en')
      );
    }
    
    const responses = await Promise.all(testRequests);
    
    // Ë®àÁÆóÂø´ÂèñÂëΩ‰∏≠Áéá
    const cacheStats = {
      hits: 0,
      misses: 0,
      stale: 0
    };
    
    responses.forEach(res => {
      const cacheHeader = res.headers['x-cache'];
      if (cacheHeader === 'HIT') cacheStats.hits++;
      else if (cacheHeader === 'MISS') cacheStats.misses++;
      else if (cacheHeader === 'STALE') cacheStats.stale++;
    });
    
    const hitRatio = cacheStats.hits / responses.length;
    
    console.log(`
      Cache Performance:
      - Hits: ${cacheStats.hits}
      - Misses: ${cacheStats.misses}
      - Stale: ${cacheStats.stale}
      - Hit ratio: ${(hitRatio * 100).toFixed(2)}%
    `);
    
    // È†êÊúü 90%+ Âø´ÂèñÂëΩ‰∏≠
    expect(hitRatio).toBeGreaterThan(0.9);
  });

  test('Database connection pool under stress', async () => {
    const iterations = 100;
    const queries = [];
    
    // Âø´ÈÄüÂü∑Ë°åÂ§ßÈáèË≥áÊñôÂ∫´Êü•Ë©¢
    for (let i = 0; i < iterations; i++) {
      queries.push(
        env.getDbPool().query('SELECT 1')
      );
    }
    
    const startTime = performance.now();
    await Promise.all(queries);
    const endTime = performance.now();
    
    const totalTime = endTime - startTime;
    const avgQueryTime = totalTime / iterations;
    
    console.log(`
      Database Performance:
      - Total queries: ${iterations}
      - Total time: ${totalTime.toFixed(2)}ms
      - Average query time: ${avgQueryTime.toFixed(2)}ms
    `);
    
    // Âπ≥ÂùáÊü•Ë©¢ÊôÇÈñìÊáâË©≤ÂæàÁü≠
    expect(avgQueryTime).toBeLessThan(10);
  });

  test('Memory usage remains stable', async () => {
    const initialMemory = process.memoryUsage();
    
    // Âü∑Ë°åÂ§ßÈáèÊìç‰Ωú
    const operations = [];
    for (let i = 0; i < 100; i++) {
      operations.push(
        request(app)
          .get('/api/pbl/scenarios')
          .set('Authorization', `Bearer ${tokens[0]}`)
      );
    }
    
    await Promise.all(operations);
    
    // Âº∑Âà∂ garbage collectionÔºàÂ¶ÇÊûúÂèØÁî®Ôºâ
    if (global.gc) {
      global.gc();
    }
    
    const finalMemory = process.memoryUsage();
    
    // Ë®àÁÆóË®òÊÜ∂È´îÂ¢ûÈï∑
    const memoryGrowth = {
      heapUsed: finalMemory.heapUsed - initialMemory.heapUsed,
      external: finalMemory.external - initialMemory.external
    };
    
    console.log(`
      Memory Usage:
      - Initial heap: ${(initialMemory.heapUsed / 1024 / 1024).toFixed(2)}MB
      - Final heap: ${(finalMemory.heapUsed / 1024 / 1024).toFixed(2)}MB
      - Growth: ${(memoryGrowth.heapUsed / 1024 / 1024).toFixed(2)}MB
    `);
    
    // Ë®òÊÜ∂È´îÂ¢ûÈï∑‰∏çÊáâË∂ÖÈÅé 100MB
    expect(memoryGrowth.heapUsed).toBeLessThan(100 * 1024 * 1024);
  });
});
```

## üîß Step 5: Ë®≠ÂÆöÊ™îÊ°à

### 5.1 Jest Integration Ë®≠ÂÆö

**üìÅ `/frontend/jest.integration.config.js`**

```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/tests/integration'],
  testMatch: ['**/*.test.ts'],
  setupFilesAfterEnv: ['<rootDir>/tests/integration/setup/jest.setup.ts'],
  globalSetup: '<rootDir>/tests/integration/setup/global-setup.ts',
  globalTeardown: '<rootDir>/tests/integration/setup/global-teardown.ts',
  testTimeout: 30000,
  maxWorkers: 1,
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.test.{ts,tsx}',
    '!src/**/index.ts'
  ],
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '/.next/',
    '/coverage/'
  ],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1'
  },
  globals: {
    'ts-jest': {
      tsconfig: {
        jsx: 'react'
      }
    }
  }
};
```

### 5.2 NPM Scripts

**üìÅ `/frontend/package.json` Êõ¥Êñ∞**

```json
{
  "scripts": {
    "test:integration": "jest --config jest.integration.config.js --runInBand",
    "test:integration:watch": "jest --config jest.integration.config.js --watch --runInBand",
    "test:integration:coverage": "jest --config jest.integration.config.js --coverage --runInBand",
    "test:integration:debug": "node --inspect-brk ./node_modules/.bin/jest --config jest.integration.config.js --runInBand",
    "test:load": "jest tests/integration/performance --config jest.integration.config.js --maxWorkers=1",
    "test:cache": "jest tests/integration/cache --config jest.integration.config.js --runInBand",
    "test:flows": "jest tests/integration/flows --config jest.integration.config.js --runInBand",
    "test:pyramid": "npm run test:unit && npm run test:integration && npm run test:e2e",
    "test:all": "npm run test:pyramid && npm run test:load"
  }
}
```

### 5.3 Docker Compose Ê∏¨Ë©¶Áí∞Â¢É

**üìÅ `/frontend/docker-compose.test.yml`**

```yaml
version: '3.8'

services:
  postgres-test:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: postgres
    ports:
      - "5433:5432"
    volumes:
      - postgres-test-data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis-test:
    image: redis:7-alpine
    ports:
      - "6380:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 5s
      retries: 5

volumes:
  postgres-test-data:
```

## üìä Âü∑Ë°åËàáÁõ£Êéß

### Âü∑Ë°åÊ∏¨Ë©¶

```bash
# 1. ÂïüÂãïÊ∏¨Ë©¶Áí∞Â¢É
docker-compose -f docker-compose.test.yml up -d

# 2. Âü∑Ë°åÊâÄÊúâÊï¥ÂêàÊ∏¨Ë©¶
npm run test:integration

# 3. Âü∑Ë°åÁâπÂÆöÊ∏¨Ë©¶Â•ó‰ª∂
npm run test:flows           # Â≠∏ÁøíÊµÅÁ®ãÊ∏¨Ë©¶
npm run test:cache           # Âø´ÂèñÊ∏¨Ë©¶
npm run test:load            # Ë≤†ËºâÊ∏¨Ë©¶

# 4. Áî¢ÁîüË¶ÜËìãÁéáÂ†±Âëä
npm run test:integration:coverage
open coverage/lcov-report/index.html

# 5. Debug Ê®°Âºè
npm run test:integration:debug
```

### CI/CD Êï¥Âêà

**üìÅ `.github/workflows/integration-tests.yml`**

```yaml
name: Integration Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  integration-tests:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5433:5432
          
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v3
      
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run integration tests
        env:
          TEST_DB_HOST: localhost
          TEST_DB_PORT: 5433
          TEST_REDIS_HOST: localhost
          TEST_REDIS_PORT: 6379
        run: npm run test:integration:coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info
          flags: integration
```

## üìà È†êÊúüÊàêÊûú

### Ë¶ÜËìãÁéáÊèêÂçá
```
Current State:
‚îú‚îÄ‚îÄ Unit Tests: 76.59%
‚îú‚îÄ‚îÄ Integration Tests: 0% ‚Üí 85%
‚îî‚îÄ‚îÄ E2E Tests: ~20%

Target State:
‚îú‚îÄ‚îÄ Unit Tests: 77%
‚îú‚îÄ‚îÄ Integration Tests: 85%
‚îî‚îÄ‚îÄ Overall Coverage: 82%+
```

### Ê∏¨Ë©¶ÈáëÂ≠óÂ°îÂàÜ‰Ωà
```
         /\
        /E2E\      10% - Critical user journeys
       /------\
      /  Integ \   30% - API & DB integration
     /----------\
    /   Unit     \ 60% - Business logic
   /--------------\
```

### ÂìÅË≥™ÊåáÊ®ôÈÅîÊàê
- ‚úÖ ÈóúÈçµ‰ΩøÁî®ËÄÖÊµÅÁ®ã 100% Ë¶ÜËìã
- ‚úÖ API Êï¥ÂêàÊ∏¨Ë©¶Ë¶ÜËìãÁéá > 90%
- ‚úÖ Âø´Âèñ‰∏ÄËá¥ÊÄß‰øùË≠â
- ‚úÖ ÊïàËÉΩÂü∫Ê∫ñÂª∫Á´ã (P95 < 1s)
- ‚úÖ ‰∏¶ÁôºÊ∏¨Ë©¶ÈÄöÈÅé (50+ users)

## ‚ö†Ô∏è ÊúÄ‰Ω≥ÂØ¶Ë∏êËàáÊ≥®ÊÑè‰∫ãÈ†Ö

### Do's ‚úÖ
1. **Ê∏¨Ë©¶ÈöîÈõ¢**: ÊØèÂÄãÊ∏¨Ë©¶‰ΩøÁî®Áç®Á´ãÁöÑË≥áÊñôÂ∫´
2. **‰∏¶Ë°åÊéßÂà∂**: ‰ΩøÁî® `--runInBand` ÈÅøÂÖçË°ùÁ™Å
3. **Ê∏ÖÁêÜÁ≠ñÁï•**: `afterEach` Ê∏ÖÁêÜÊ∏¨Ë©¶Ë≥áÊñô
4. **Ë∂ÖÊôÇË®≠ÂÆö**: 30 ÁßíÁµ¶Êï¥ÂêàÊ∏¨Ë©¶Ë∂≥Â§†ÊôÇÈñì
5. **Mock Â§ñÈÉ®ÊúçÂãô**: AI API ‰ΩøÁî® mock

### Don'ts ‚ùå
1. **‰∏çË¶ÅÂÖ±‰∫´Ê∏¨Ë©¶Ë≥áÊñô**: ÈÅøÂÖçÊ∏¨Ë©¶Èñì‰æùË≥¥
2. **‰∏çË¶ÅË∑≥ÈÅéÊ∏ÖÁêÜ**: ÊúÉÈÄ†ÊàêË≥áÊñôÊ±°Êüì
3. **‰∏çË¶Å‰∏¶Ë°åÂü∑Ë°å**: Ë≥áÊñôÂ∫´Êìç‰ΩúÂèØËÉΩË°ùÁ™Å
4. **‰∏çË¶ÅÁ°¨Á∑®Á¢ºÁ≠âÂæÖ**: ‰ΩøÁî® `waitFor` helper
5. **‰∏çË¶ÅÂøΩÁï•ÈåØË™§**: Ë®òÈåÑ‰∏¶ÂàÜÊûêÂ§±ÊïóÂéüÂõ†

## üöÄ Quick Start Checklist

- [ ] ÂÆâË£ù Docker Desktop
- [ ] Ë§áË£ΩÊ∏¨Ë©¶Áí∞Â¢ÉË®≠ÂÆöÊ™î
- [ ] ÂïüÂãïÊ∏¨Ë©¶Ë≥áÊñôÂ∫´Âíå Redis
- [ ] Âü∑Ë°åÁ¨¨‰∏ÄÂÄãÊï¥ÂêàÊ∏¨Ë©¶
- [ ] Êü•ÁúãË¶ÜËìãÁéáÂ†±Âëä
- [ ] Êï¥ÂêàÂà∞ CI/CD pipeline

## üìö Áõ∏ÈóúÊñá‰ª∂

- [Ê∏¨Ë©¶Ë¶ÜËìãÁéáÂàÜÊûê](../coverage-analysis.md)
- [Ê∏¨Ë©¶Á≠ñÁï•Êñá‰ª∂](../TESTING-STRATEGY.md)
- [API Êñá‰ª∂](../api/README.md)
- [Ë≥áÊñôÂ∫´Êû∂Êßã](../database/schema.md)

---

*ÊúÄÂæåÊõ¥Êñ∞: 2025-08-11 | ‰ΩúËÄÖ: AI Square Engineering Team*